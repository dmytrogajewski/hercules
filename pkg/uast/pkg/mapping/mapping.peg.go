package mapping

// Code generated by /home/dmytrogajewski/go/bin/peg mapping.peg DO NOT EDIT.

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleStart
	ruleSpacing
	ruleSpace
	ruleLanguageDeclaration
	ruleExtensionsSection
	ruleFilesSection
	ruleLanguageName
	ruleExtensionList
	ruleExtension
	ruleFileList
	ruleFile
	ruleComment
	ruleRuleList
	ruleRule
	ruleIdentifier
	rulePattern
	ruleNodeType
	rulePatternElements
	rulePatternElement
	ruleField
	ruleFieldName
	ruleFieldValue
	ruleCapturedElement
	ruleCapture
	ruleUASTSpec
	ruleUASTFields
	ruleUASTField
	ruleUASTFieldValue
	ruleMultipleCaptures
	ruleMultipleStrings
	ruleString
	ruleCondition
	ruleConditionList
	ruleOperator
	ruleInheritanceComment
	ruleErrorRecovery
	ruleUASTFieldName
)

var rul3s = [...]string{
	"Unknown",
	"Start",
	"Spacing",
	"Space",
	"LanguageDeclaration",
	"ExtensionsSection",
	"FilesSection",
	"LanguageName",
	"ExtensionList",
	"Extension",
	"FileList",
	"File",
	"Comment",
	"RuleList",
	"Rule",
	"Identifier",
	"Pattern",
	"NodeType",
	"PatternElements",
	"PatternElement",
	"Field",
	"FieldName",
	"FieldValue",
	"CapturedElement",
	"Capture",
	"UASTSpec",
	"UASTFields",
	"UASTField",
	"UASTFieldValue",
	"MultipleCaptures",
	"MultipleStrings",
	"String",
	"Condition",
	"ConditionList",
	"Operator",
	"InheritanceComment",
	"ErrorRecovery",
	"UASTFieldName",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type MappingDSL struct {
	Buffer string
	buffer []rune
	rules  [38]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *MappingDSL) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *MappingDSL) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *MappingDSL
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *MappingDSL) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *MappingDSL) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *MappingDSL) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func Pretty(pretty bool) func(*MappingDSL) error {
	return func(p *MappingDSL) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*MappingDSL) error {
	return func(p *MappingDSL) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *MappingDSL) Init(options ...func(*MappingDSL) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 Start <- <(Spacing LanguageDeclaration? Spacing RuleList Spacing !.)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				if !_rules[ruleSpacing]() {
					goto l0
				}
				{
					position2, tokenIndex2 := position, tokenIndex
					if !_rules[ruleLanguageDeclaration]() {
						goto l2
					}
					goto l3
				l2:
					position, tokenIndex = position2, tokenIndex2
				}
			l3:
				if !_rules[ruleSpacing]() {
					goto l0
				}
				if !_rules[ruleRuleList]() {
					goto l0
				}
				if !_rules[ruleSpacing]() {
					goto l0
				}
				{
					position4, tokenIndex4 := position, tokenIndex
					if !matchDot() {
						goto l4
					}
					goto l0
				l4:
					position, tokenIndex = position4, tokenIndex4
				}
				add(ruleStart, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 Spacing <- <Space*> */
		func() bool {
			{
				position6 := position
			l7:
				{
					position8, tokenIndex8 := position, tokenIndex
					if !_rules[ruleSpace]() {
						goto l8
					}
					goto l7
				l8:
					position, tokenIndex = position8, tokenIndex8
				}
				add(ruleSpacing, position6)
			}
			return true
		},
		/* 2 Space <- <(' ' / '\t' / '\r' / '\n')+> */
		func() bool {
			position9, tokenIndex9 := position, tokenIndex
			{
				position10 := position
				{
					position13, tokenIndex13 := position, tokenIndex
					if buffer[position] != rune(' ') {
						goto l14
					}
					position++
					goto l13
				l14:
					position, tokenIndex = position13, tokenIndex13
					if buffer[position] != rune('\t') {
						goto l15
					}
					position++
					goto l13
				l15:
					position, tokenIndex = position13, tokenIndex13
					if buffer[position] != rune('\r') {
						goto l16
					}
					position++
					goto l13
				l16:
					position, tokenIndex = position13, tokenIndex13
					if buffer[position] != rune('\n') {
						goto l9
					}
					position++
				}
			l13:
			l11:
				{
					position12, tokenIndex12 := position, tokenIndex
					{
						position17, tokenIndex17 := position, tokenIndex
						if buffer[position] != rune(' ') {
							goto l18
						}
						position++
						goto l17
					l18:
						position, tokenIndex = position17, tokenIndex17
						if buffer[position] != rune('\t') {
							goto l19
						}
						position++
						goto l17
					l19:
						position, tokenIndex = position17, tokenIndex17
						if buffer[position] != rune('\r') {
							goto l20
						}
						position++
						goto l17
					l20:
						position, tokenIndex = position17, tokenIndex17
						if buffer[position] != rune('\n') {
							goto l12
						}
						position++
					}
				l17:
					goto l11
				l12:
					position, tokenIndex = position12, tokenIndex12
				}
				add(ruleSpace, position10)
			}
			return true
		l9:
			position, tokenIndex = position9, tokenIndex9
			return false
		},
		/* 3 LanguageDeclaration <- <('[' Spacing ('l' 'a' 'n' 'g' 'u' 'a' 'g' 'e') Spacing '"' LanguageName '"' Spacing ((ExtensionsSection FilesSection?) / (FilesSection ExtensionsSection?) / ExtensionsSection / FilesSection) Spacing ']')> */
		func() bool {
			position21, tokenIndex21 := position, tokenIndex
			{
				position22 := position
				if buffer[position] != rune('[') {
					goto l21
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l21
				}
				if buffer[position] != rune('l') {
					goto l21
				}
				position++
				if buffer[position] != rune('a') {
					goto l21
				}
				position++
				if buffer[position] != rune('n') {
					goto l21
				}
				position++
				if buffer[position] != rune('g') {
					goto l21
				}
				position++
				if buffer[position] != rune('u') {
					goto l21
				}
				position++
				if buffer[position] != rune('a') {
					goto l21
				}
				position++
				if buffer[position] != rune('g') {
					goto l21
				}
				position++
				if buffer[position] != rune('e') {
					goto l21
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l21
				}
				if buffer[position] != rune('"') {
					goto l21
				}
				position++
				if !_rules[ruleLanguageName]() {
					goto l21
				}
				if buffer[position] != rune('"') {
					goto l21
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l21
				}
				{
					position23, tokenIndex23 := position, tokenIndex
					if !_rules[ruleExtensionsSection]() {
						goto l24
					}
					{
						position25, tokenIndex25 := position, tokenIndex
						if !_rules[ruleFilesSection]() {
							goto l25
						}
						goto l26
					l25:
						position, tokenIndex = position25, tokenIndex25
					}
				l26:
					goto l23
				l24:
					position, tokenIndex = position23, tokenIndex23
					if !_rules[ruleFilesSection]() {
						goto l27
					}
					{
						position28, tokenIndex28 := position, tokenIndex
						if !_rules[ruleExtensionsSection]() {
							goto l28
						}
						goto l29
					l28:
						position, tokenIndex = position28, tokenIndex28
					}
				l29:
					goto l23
				l27:
					position, tokenIndex = position23, tokenIndex23
					if !_rules[ruleExtensionsSection]() {
						goto l30
					}
					goto l23
				l30:
					position, tokenIndex = position23, tokenIndex23
					if !_rules[ruleFilesSection]() {
						goto l21
					}
				}
			l23:
				if !_rules[ruleSpacing]() {
					goto l21
				}
				if buffer[position] != rune(']') {
					goto l21
				}
				position++
				add(ruleLanguageDeclaration, position22)
			}
			return true
		l21:
			position, tokenIndex = position21, tokenIndex21
			return false
		},
		/* 4 ExtensionsSection <- <(Spacing ',' Spacing ('e' 'x' 't' 'e' 'n' 's' 'i' 'o' 'n' 's' ':') Spacing ExtensionList)> */
		func() bool {
			position31, tokenIndex31 := position, tokenIndex
			{
				position32 := position
				if !_rules[ruleSpacing]() {
					goto l31
				}
				if buffer[position] != rune(',') {
					goto l31
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l31
				}
				if buffer[position] != rune('e') {
					goto l31
				}
				position++
				if buffer[position] != rune('x') {
					goto l31
				}
				position++
				if buffer[position] != rune('t') {
					goto l31
				}
				position++
				if buffer[position] != rune('e') {
					goto l31
				}
				position++
				if buffer[position] != rune('n') {
					goto l31
				}
				position++
				if buffer[position] != rune('s') {
					goto l31
				}
				position++
				if buffer[position] != rune('i') {
					goto l31
				}
				position++
				if buffer[position] != rune('o') {
					goto l31
				}
				position++
				if buffer[position] != rune('n') {
					goto l31
				}
				position++
				if buffer[position] != rune('s') {
					goto l31
				}
				position++
				if buffer[position] != rune(':') {
					goto l31
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l31
				}
				if !_rules[ruleExtensionList]() {
					goto l31
				}
				add(ruleExtensionsSection, position32)
			}
			return true
		l31:
			position, tokenIndex = position31, tokenIndex31
			return false
		},
		/* 5 FilesSection <- <(Spacing ',' Spacing ('f' 'i' 'l' 'e' 's' ':') Spacing FileList)> */
		func() bool {
			position33, tokenIndex33 := position, tokenIndex
			{
				position34 := position
				if !_rules[ruleSpacing]() {
					goto l33
				}
				if buffer[position] != rune(',') {
					goto l33
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l33
				}
				if buffer[position] != rune('f') {
					goto l33
				}
				position++
				if buffer[position] != rune('i') {
					goto l33
				}
				position++
				if buffer[position] != rune('l') {
					goto l33
				}
				position++
				if buffer[position] != rune('e') {
					goto l33
				}
				position++
				if buffer[position] != rune('s') {
					goto l33
				}
				position++
				if buffer[position] != rune(':') {
					goto l33
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l33
				}
				if !_rules[ruleFileList]() {
					goto l33
				}
				add(ruleFilesSection, position34)
			}
			return true
		l33:
			position, tokenIndex = position33, tokenIndex33
			return false
		},
		/* 6 LanguageName <- <(([a-z] / [A-Z] / '_') ([a-z] / [A-Z] / [0-9] / '_')*)> */
		func() bool {
			position35, tokenIndex35 := position, tokenIndex
			{
				position36 := position
				{
					position37, tokenIndex37 := position, tokenIndex
					if c := buffer[position]; c < rune('a') || c > rune('z') {
						goto l38
					}
					position++
					goto l37
				l38:
					position, tokenIndex = position37, tokenIndex37
					if c := buffer[position]; c < rune('A') || c > rune('Z') {
						goto l39
					}
					position++
					goto l37
				l39:
					position, tokenIndex = position37, tokenIndex37
					if buffer[position] != rune('_') {
						goto l35
					}
					position++
				}
			l37:
			l40:
				{
					position41, tokenIndex41 := position, tokenIndex
					{
						position42, tokenIndex42 := position, tokenIndex
						if c := buffer[position]; c < rune('a') || c > rune('z') {
							goto l43
						}
						position++
						goto l42
					l43:
						position, tokenIndex = position42, tokenIndex42
						if c := buffer[position]; c < rune('A') || c > rune('Z') {
							goto l44
						}
						position++
						goto l42
					l44:
						position, tokenIndex = position42, tokenIndex42
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l45
						}
						position++
						goto l42
					l45:
						position, tokenIndex = position42, tokenIndex42
						if buffer[position] != rune('_') {
							goto l41
						}
						position++
					}
				l42:
					goto l40
				l41:
					position, tokenIndex = position41, tokenIndex41
				}
				add(ruleLanguageName, position36)
			}
			return true
		l35:
			position, tokenIndex = position35, tokenIndex35
			return false
		},
		/* 7 ExtensionList <- <(Extension (Spacing ',' Spacing Extension)*)> */
		func() bool {
			position46, tokenIndex46 := position, tokenIndex
			{
				position47 := position
				if !_rules[ruleExtension]() {
					goto l46
				}
			l48:
				{
					position49, tokenIndex49 := position, tokenIndex
					if !_rules[ruleSpacing]() {
						goto l49
					}
					if buffer[position] != rune(',') {
						goto l49
					}
					position++
					if !_rules[ruleSpacing]() {
						goto l49
					}
					if !_rules[ruleExtension]() {
						goto l49
					}
					goto l48
				l49:
					position, tokenIndex = position49, tokenIndex49
				}
				add(ruleExtensionList, position47)
			}
			return true
		l46:
			position, tokenIndex = position46, tokenIndex46
			return false
		},
		/* 8 Extension <- <('"' ([a-z] / [A-Z] / [0-9] / '_' / '.')+ '"')> */
		func() bool {
			position50, tokenIndex50 := position, tokenIndex
			{
				position51 := position
				if buffer[position] != rune('"') {
					goto l50
				}
				position++
				{
					position54, tokenIndex54 := position, tokenIndex
					if c := buffer[position]; c < rune('a') || c > rune('z') {
						goto l55
					}
					position++
					goto l54
				l55:
					position, tokenIndex = position54, tokenIndex54
					if c := buffer[position]; c < rune('A') || c > rune('Z') {
						goto l56
					}
					position++
					goto l54
				l56:
					position, tokenIndex = position54, tokenIndex54
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l57
					}
					position++
					goto l54
				l57:
					position, tokenIndex = position54, tokenIndex54
					if buffer[position] != rune('_') {
						goto l58
					}
					position++
					goto l54
				l58:
					position, tokenIndex = position54, tokenIndex54
					if buffer[position] != rune('.') {
						goto l50
					}
					position++
				}
			l54:
			l52:
				{
					position53, tokenIndex53 := position, tokenIndex
					{
						position59, tokenIndex59 := position, tokenIndex
						if c := buffer[position]; c < rune('a') || c > rune('z') {
							goto l60
						}
						position++
						goto l59
					l60:
						position, tokenIndex = position59, tokenIndex59
						if c := buffer[position]; c < rune('A') || c > rune('Z') {
							goto l61
						}
						position++
						goto l59
					l61:
						position, tokenIndex = position59, tokenIndex59
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l62
						}
						position++
						goto l59
					l62:
						position, tokenIndex = position59, tokenIndex59
						if buffer[position] != rune('_') {
							goto l63
						}
						position++
						goto l59
					l63:
						position, tokenIndex = position59, tokenIndex59
						if buffer[position] != rune('.') {
							goto l53
						}
						position++
					}
				l59:
					goto l52
				l53:
					position, tokenIndex = position53, tokenIndex53
				}
				if buffer[position] != rune('"') {
					goto l50
				}
				position++
				add(ruleExtension, position51)
			}
			return true
		l50:
			position, tokenIndex = position50, tokenIndex50
			return false
		},
		/* 9 FileList <- <(File (Spacing ',' Spacing File)*)> */
		func() bool {
			position64, tokenIndex64 := position, tokenIndex
			{
				position65 := position
				if !_rules[ruleFile]() {
					goto l64
				}
			l66:
				{
					position67, tokenIndex67 := position, tokenIndex
					if !_rules[ruleSpacing]() {
						goto l67
					}
					if buffer[position] != rune(',') {
						goto l67
					}
					position++
					if !_rules[ruleSpacing]() {
						goto l67
					}
					if !_rules[ruleFile]() {
						goto l67
					}
					goto l66
				l67:
					position, tokenIndex = position67, tokenIndex67
				}
				add(ruleFileList, position65)
			}
			return true
		l64:
			position, tokenIndex = position64, tokenIndex64
			return false
		},
		/* 10 File <- <('"' ([a-z] / [A-Z] / [0-9] / '_' / '.')+ '"')> */
		func() bool {
			position68, tokenIndex68 := position, tokenIndex
			{
				position69 := position
				if buffer[position] != rune('"') {
					goto l68
				}
				position++
				{
					position72, tokenIndex72 := position, tokenIndex
					if c := buffer[position]; c < rune('a') || c > rune('z') {
						goto l73
					}
					position++
					goto l72
				l73:
					position, tokenIndex = position72, tokenIndex72
					if c := buffer[position]; c < rune('A') || c > rune('Z') {
						goto l74
					}
					position++
					goto l72
				l74:
					position, tokenIndex = position72, tokenIndex72
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l75
					}
					position++
					goto l72
				l75:
					position, tokenIndex = position72, tokenIndex72
					if buffer[position] != rune('_') {
						goto l76
					}
					position++
					goto l72
				l76:
					position, tokenIndex = position72, tokenIndex72
					if buffer[position] != rune('.') {
						goto l68
					}
					position++
				}
			l72:
			l70:
				{
					position71, tokenIndex71 := position, tokenIndex
					{
						position77, tokenIndex77 := position, tokenIndex
						if c := buffer[position]; c < rune('a') || c > rune('z') {
							goto l78
						}
						position++
						goto l77
					l78:
						position, tokenIndex = position77, tokenIndex77
						if c := buffer[position]; c < rune('A') || c > rune('Z') {
							goto l79
						}
						position++
						goto l77
					l79:
						position, tokenIndex = position77, tokenIndex77
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l80
						}
						position++
						goto l77
					l80:
						position, tokenIndex = position77, tokenIndex77
						if buffer[position] != rune('_') {
							goto l81
						}
						position++
						goto l77
					l81:
						position, tokenIndex = position77, tokenIndex77
						if buffer[position] != rune('.') {
							goto l71
						}
						position++
					}
				l77:
					goto l70
				l71:
					position, tokenIndex = position71, tokenIndex71
				}
				if buffer[position] != rune('"') {
					goto l68
				}
				position++
				add(ruleFile, position69)
			}
			return true
		l68:
			position, tokenIndex = position68, tokenIndex68
			return false
		},
		/* 11 Comment <- <('/' '/' (!('\r' / '\n') .)*)> */
		nil,
		/* 12 RuleList <- <(Rule (Spacing Rule)*)> */
		func() bool {
			position83, tokenIndex83 := position, tokenIndex
			{
				position84 := position
				if !_rules[ruleRule]() {
					goto l83
				}
			l85:
				{
					position86, tokenIndex86 := position, tokenIndex
					if !_rules[ruleSpacing]() {
						goto l86
					}
					if !_rules[ruleRule]() {
						goto l86
					}
					goto l85
				l86:
					position, tokenIndex = position86, tokenIndex86
				}
				add(ruleRuleList, position84)
			}
			return true
		l83:
			position, tokenIndex = position83, tokenIndex83
			return false
		},
		/* 13 Rule <- <(Identifier Spacing ('<' '-') Spacing Pattern Spacing ('=' '>') Spacing UASTSpec (Spacing ConditionList)? (Spacing InheritanceComment)? (Spacing ConditionList)?)> */
		func() bool {
			position87, tokenIndex87 := position, tokenIndex
			{
				position88 := position
				if !_rules[ruleIdentifier]() {
					goto l87
				}
				if !_rules[ruleSpacing]() {
					goto l87
				}
				if buffer[position] != rune('<') {
					goto l87
				}
				position++
				if buffer[position] != rune('-') {
					goto l87
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l87
				}
				if !_rules[rulePattern]() {
					goto l87
				}
				if !_rules[ruleSpacing]() {
					goto l87
				}
				if buffer[position] != rune('=') {
					goto l87
				}
				position++
				if buffer[position] != rune('>') {
					goto l87
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l87
				}
				if !_rules[ruleUASTSpec]() {
					goto l87
				}
				{
					position89, tokenIndex89 := position, tokenIndex
					if !_rules[ruleSpacing]() {
						goto l89
					}
					if !_rules[ruleConditionList]() {
						goto l89
					}
					goto l90
				l89:
					position, tokenIndex = position89, tokenIndex89
				}
			l90:
				{
					position91, tokenIndex91 := position, tokenIndex
					if !_rules[ruleSpacing]() {
						goto l91
					}
					if !_rules[ruleInheritanceComment]() {
						goto l91
					}
					goto l92
				l91:
					position, tokenIndex = position91, tokenIndex91
				}
			l92:
				{
					position93, tokenIndex93 := position, tokenIndex
					if !_rules[ruleSpacing]() {
						goto l93
					}
					if !_rules[ruleConditionList]() {
						goto l93
					}
					goto l94
				l93:
					position, tokenIndex = position93, tokenIndex93
				}
			l94:
				add(ruleRule, position88)
			}
			return true
		l87:
			position, tokenIndex = position87, tokenIndex87
			return false
		},
		/* 14 Identifier <- <(([a-z] / [A-Z] / '_') ([a-z] / [A-Z] / [0-9] / '_')*)> */
		func() bool {
			position95, tokenIndex95 := position, tokenIndex
			{
				position96 := position
				{
					position97, tokenIndex97 := position, tokenIndex
					if c := buffer[position]; c < rune('a') || c > rune('z') {
						goto l98
					}
					position++
					goto l97
				l98:
					position, tokenIndex = position97, tokenIndex97
					if c := buffer[position]; c < rune('A') || c > rune('Z') {
						goto l99
					}
					position++
					goto l97
				l99:
					position, tokenIndex = position97, tokenIndex97
					if buffer[position] != rune('_') {
						goto l95
					}
					position++
				}
			l97:
			l100:
				{
					position101, tokenIndex101 := position, tokenIndex
					{
						position102, tokenIndex102 := position, tokenIndex
						if c := buffer[position]; c < rune('a') || c > rune('z') {
							goto l103
						}
						position++
						goto l102
					l103:
						position, tokenIndex = position102, tokenIndex102
						if c := buffer[position]; c < rune('A') || c > rune('Z') {
							goto l104
						}
						position++
						goto l102
					l104:
						position, tokenIndex = position102, tokenIndex102
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l105
						}
						position++
						goto l102
					l105:
						position, tokenIndex = position102, tokenIndex102
						if buffer[position] != rune('_') {
							goto l101
						}
						position++
					}
				l102:
					goto l100
				l101:
					position, tokenIndex = position101, tokenIndex101
				}
				add(ruleIdentifier, position96)
			}
			return true
		l95:
			position, tokenIndex = position95, tokenIndex95
			return false
		},
		/* 15 Pattern <- <('(' Spacing NodeType PatternElements Spacing ')')> */
		func() bool {
			position106, tokenIndex106 := position, tokenIndex
			{
				position107 := position
				if buffer[position] != rune('(') {
					goto l106
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l106
				}
				if !_rules[ruleNodeType]() {
					goto l106
				}
				if !_rules[rulePatternElements]() {
					goto l106
				}
				if !_rules[ruleSpacing]() {
					goto l106
				}
				if buffer[position] != rune(')') {
					goto l106
				}
				position++
				add(rulePattern, position107)
			}
			return true
		l106:
			position, tokenIndex = position106, tokenIndex106
			return false
		},
		/* 16 NodeType <- <Identifier> */
		func() bool {
			position108, tokenIndex108 := position, tokenIndex
			{
				position109 := position
				if !_rules[ruleIdentifier]() {
					goto l108
				}
				add(ruleNodeType, position109)
			}
			return true
		l108:
			position, tokenIndex = position108, tokenIndex108
			return false
		},
		/* 17 PatternElements <- <(Spacing PatternElement)*> */
		func() bool {
			{
				position111 := position
			l112:
				{
					position113, tokenIndex113 := position, tokenIndex
					if !_rules[ruleSpacing]() {
						goto l113
					}
					if !_rules[rulePatternElement]() {
						goto l113
					}
					goto l112
				l113:
					position, tokenIndex = position113, tokenIndex113
				}
				add(rulePatternElements, position111)
			}
			return true
		},
		/* 18 PatternElement <- <(Field / CapturedElement / Identifier)> */
		func() bool {
			position114, tokenIndex114 := position, tokenIndex
			{
				position115 := position
				{
					position116, tokenIndex116 := position, tokenIndex
					if !_rules[ruleField]() {
						goto l117
					}
					goto l116
				l117:
					position, tokenIndex = position116, tokenIndex116
					if !_rules[ruleCapturedElement]() {
						goto l118
					}
					goto l116
				l118:
					position, tokenIndex = position116, tokenIndex116
					if !_rules[ruleIdentifier]() {
						goto l114
					}
				}
			l116:
				add(rulePatternElement, position115)
			}
			return true
		l114:
			position, tokenIndex = position114, tokenIndex114
			return false
		},
		/* 19 Field <- <(FieldName ':' Spacing FieldValue)> */
		func() bool {
			position119, tokenIndex119 := position, tokenIndex
			{
				position120 := position
				if !_rules[ruleFieldName]() {
					goto l119
				}
				if buffer[position] != rune(':') {
					goto l119
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l119
				}
				if !_rules[ruleFieldValue]() {
					goto l119
				}
				add(ruleField, position120)
			}
			return true
		l119:
			position, tokenIndex = position119, tokenIndex119
			return false
		},
		/* 20 FieldName <- <Identifier> */
		func() bool {
			position121, tokenIndex121 := position, tokenIndex
			{
				position122 := position
				if !_rules[ruleIdentifier]() {
					goto l121
				}
				add(ruleFieldName, position122)
			}
			return true
		l121:
			position, tokenIndex = position121, tokenIndex121
			return false
		},
		/* 21 FieldValue <- <('(' Identifier ')' Spacing Capture?)> */
		func() bool {
			position123, tokenIndex123 := position, tokenIndex
			{
				position124 := position
				if buffer[position] != rune('(') {
					goto l123
				}
				position++
				if !_rules[ruleIdentifier]() {
					goto l123
				}
				if buffer[position] != rune(')') {
					goto l123
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l123
				}
				{
					position125, tokenIndex125 := position, tokenIndex
					if !_rules[ruleCapture]() {
						goto l125
					}
					goto l126
				l125:
					position, tokenIndex = position125, tokenIndex125
				}
			l126:
				add(ruleFieldValue, position124)
			}
			return true
		l123:
			position, tokenIndex = position123, tokenIndex123
			return false
		},
		/* 22 CapturedElement <- <('(' Identifier ')' Spacing Capture)> */
		func() bool {
			position127, tokenIndex127 := position, tokenIndex
			{
				position128 := position
				if buffer[position] != rune('(') {
					goto l127
				}
				position++
				if !_rules[ruleIdentifier]() {
					goto l127
				}
				if buffer[position] != rune(')') {
					goto l127
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l127
				}
				if !_rules[ruleCapture]() {
					goto l127
				}
				add(ruleCapturedElement, position128)
			}
			return true
		l127:
			position, tokenIndex = position127, tokenIndex127
			return false
		},
		/* 23 Capture <- <('@' Identifier)> */
		func() bool {
			position129, tokenIndex129 := position, tokenIndex
			{
				position130 := position
				if buffer[position] != rune('@') {
					goto l129
				}
				position++
				if !_rules[ruleIdentifier]() {
					goto l129
				}
				add(ruleCapture, position130)
			}
			return true
		l129:
			position, tokenIndex = position129, tokenIndex129
			return false
		},
		/* 24 UASTSpec <- <('u' 'a' 's' 't' '(' Spacing UASTFields Spacing ')')> */
		func() bool {
			position131, tokenIndex131 := position, tokenIndex
			{
				position132 := position
				if buffer[position] != rune('u') {
					goto l131
				}
				position++
				if buffer[position] != rune('a') {
					goto l131
				}
				position++
				if buffer[position] != rune('s') {
					goto l131
				}
				position++
				if buffer[position] != rune('t') {
					goto l131
				}
				position++
				if buffer[position] != rune('(') {
					goto l131
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l131
				}
				if !_rules[ruleUASTFields]() {
					goto l131
				}
				if !_rules[ruleSpacing]() {
					goto l131
				}
				if buffer[position] != rune(')') {
					goto l131
				}
				position++
				add(ruleUASTSpec, position132)
			}
			return true
		l131:
			position, tokenIndex = position131, tokenIndex131
			return false
		},
		/* 25 UASTFields <- <(UASTField (Spacing ',' Spacing UASTField)*)> */
		func() bool {
			position133, tokenIndex133 := position, tokenIndex
			{
				position134 := position
				if !_rules[ruleUASTField]() {
					goto l133
				}
			l135:
				{
					position136, tokenIndex136 := position, tokenIndex
					if !_rules[ruleSpacing]() {
						goto l136
					}
					if buffer[position] != rune(',') {
						goto l136
					}
					position++
					if !_rules[ruleSpacing]() {
						goto l136
					}
					if !_rules[ruleUASTField]() {
						goto l136
					}
					goto l135
				l136:
					position, tokenIndex = position136, tokenIndex136
				}
				add(ruleUASTFields, position134)
			}
			return true
		l133:
			position, tokenIndex = position133, tokenIndex133
			return false
		},
		/* 26 UASTField <- <(UASTFieldName ':' Spacing UASTFieldValue)> */
		func() bool {
			position137, tokenIndex137 := position, tokenIndex
			{
				position138 := position
				if !_rules[ruleUASTFieldName]() {
					goto l137
				}
				if buffer[position] != rune(':') {
					goto l137
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l137
				}
				if !_rules[ruleUASTFieldValue]() {
					goto l137
				}
				add(ruleUASTField, position138)
			}
			return true
		l137:
			position, tokenIndex = position137, tokenIndex137
			return false
		},
		/* 27 UASTFieldValue <- <(MultipleStrings / String / MultipleCaptures / Capture / Identifier)> */
		func() bool {
			position139, tokenIndex139 := position, tokenIndex
			{
				position140 := position
				{
					position141, tokenIndex141 := position, tokenIndex
					if !_rules[ruleMultipleStrings]() {
						goto l142
					}
					goto l141
				l142:
					position, tokenIndex = position141, tokenIndex141
					if !_rules[ruleString]() {
						goto l143
					}
					goto l141
				l143:
					position, tokenIndex = position141, tokenIndex141
					if !_rules[ruleMultipleCaptures]() {
						goto l144
					}
					goto l141
				l144:
					position, tokenIndex = position141, tokenIndex141
					if !_rules[ruleCapture]() {
						goto l145
					}
					goto l141
				l145:
					position, tokenIndex = position141, tokenIndex141
					if !_rules[ruleIdentifier]() {
						goto l139
					}
				}
			l141:
				add(ruleUASTFieldValue, position140)
			}
			return true
		l139:
			position, tokenIndex = position139, tokenIndex139
			return false
		},
		/* 28 MultipleCaptures <- <(Capture (Spacing ',' Spacing Capture)*)> */
		func() bool {
			position146, tokenIndex146 := position, tokenIndex
			{
				position147 := position
				if !_rules[ruleCapture]() {
					goto l146
				}
			l148:
				{
					position149, tokenIndex149 := position, tokenIndex
					if !_rules[ruleSpacing]() {
						goto l149
					}
					if buffer[position] != rune(',') {
						goto l149
					}
					position++
					if !_rules[ruleSpacing]() {
						goto l149
					}
					if !_rules[ruleCapture]() {
						goto l149
					}
					goto l148
				l149:
					position, tokenIndex = position149, tokenIndex149
				}
				add(ruleMultipleCaptures, position147)
			}
			return true
		l146:
			position, tokenIndex = position146, tokenIndex146
			return false
		},
		/* 29 MultipleStrings <- <(String (',' Spacing String)*)> */
		func() bool {
			position150, tokenIndex150 := position, tokenIndex
			{
				position151 := position
				if !_rules[ruleString]() {
					goto l150
				}
			l152:
				{
					position153, tokenIndex153 := position, tokenIndex
					if buffer[position] != rune(',') {
						goto l153
					}
					position++
					if !_rules[ruleSpacing]() {
						goto l153
					}
					if !_rules[ruleString]() {
						goto l153
					}
					goto l152
				l153:
					position, tokenIndex = position153, tokenIndex153
				}
				add(ruleMultipleStrings, position151)
			}
			return true
		l150:
			position, tokenIndex = position150, tokenIndex150
			return false
		},
		/* 30 String <- <('"' (!'"' .)* '"')> */
		func() bool {
			position154, tokenIndex154 := position, tokenIndex
			{
				position155 := position
				if buffer[position] != rune('"') {
					goto l154
				}
				position++
			l156:
				{
					position157, tokenIndex157 := position, tokenIndex
					{
						position158, tokenIndex158 := position, tokenIndex
						if buffer[position] != rune('"') {
							goto l158
						}
						position++
						goto l157
					l158:
						position, tokenIndex = position158, tokenIndex158
					}
					if !matchDot() {
						goto l157
					}
					goto l156
				l157:
					position, tokenIndex = position157, tokenIndex157
				}
				if buffer[position] != rune('"') {
					goto l154
				}
				position++
				add(ruleString, position155)
			}
			return true
		l154:
			position, tokenIndex = position154, tokenIndex154
			return false
		},
		/* 31 Condition <- <(Identifier Spacing Operator Spacing String)> */
		func() bool {
			position159, tokenIndex159 := position, tokenIndex
			{
				position160 := position
				if !_rules[ruleIdentifier]() {
					goto l159
				}
				if !_rules[ruleSpacing]() {
					goto l159
				}
				if !_rules[ruleOperator]() {
					goto l159
				}
				if !_rules[ruleSpacing]() {
					goto l159
				}
				if !_rules[ruleString]() {
					goto l159
				}
				add(ruleCondition, position160)
			}
			return true
		l159:
			position, tokenIndex = position159, tokenIndex159
			return false
		},
		/* 32 ConditionList <- <('w' 'h' 'e' 'n' Spacing Condition (Spacing ('a' 'n' 'd') Spacing Condition)*)> */
		func() bool {
			position161, tokenIndex161 := position, tokenIndex
			{
				position162 := position
				if buffer[position] != rune('w') {
					goto l161
				}
				position++
				if buffer[position] != rune('h') {
					goto l161
				}
				position++
				if buffer[position] != rune('e') {
					goto l161
				}
				position++
				if buffer[position] != rune('n') {
					goto l161
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l161
				}
				if !_rules[ruleCondition]() {
					goto l161
				}
			l163:
				{
					position164, tokenIndex164 := position, tokenIndex
					if !_rules[ruleSpacing]() {
						goto l164
					}
					if buffer[position] != rune('a') {
						goto l164
					}
					position++
					if buffer[position] != rune('n') {
						goto l164
					}
					position++
					if buffer[position] != rune('d') {
						goto l164
					}
					position++
					if !_rules[ruleSpacing]() {
						goto l164
					}
					if !_rules[ruleCondition]() {
						goto l164
					}
					goto l163
				l164:
					position, tokenIndex = position164, tokenIndex164
				}
				add(ruleConditionList, position162)
			}
			return true
		l161:
			position, tokenIndex = position161, tokenIndex161
			return false
		},
		/* 33 Operator <- <(('=' '=') / ('!' '='))> */
		func() bool {
			position165, tokenIndex165 := position, tokenIndex
			{
				position166 := position
				{
					position167, tokenIndex167 := position, tokenIndex
					if buffer[position] != rune('=') {
						goto l168
					}
					position++
					if buffer[position] != rune('=') {
						goto l168
					}
					position++
					goto l167
				l168:
					position, tokenIndex = position167, tokenIndex167
					if buffer[position] != rune('!') {
						goto l165
					}
					position++
					if buffer[position] != rune('=') {
						goto l165
					}
					position++
				}
			l167:
				add(ruleOperator, position166)
			}
			return true
		l165:
			position, tokenIndex = position165, tokenIndex165
			return false
		},
		/* 34 InheritanceComment <- <('#' Spacing ('E' 'x' 't' 'e' 'n' 'd' 's') Spacing Identifier ConditionList?)> */
		func() bool {
			position169, tokenIndex169 := position, tokenIndex
			{
				position170 := position
				if buffer[position] != rune('#') {
					goto l169
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l169
				}
				if buffer[position] != rune('E') {
					goto l169
				}
				position++
				if buffer[position] != rune('x') {
					goto l169
				}
				position++
				if buffer[position] != rune('t') {
					goto l169
				}
				position++
				if buffer[position] != rune('e') {
					goto l169
				}
				position++
				if buffer[position] != rune('n') {
					goto l169
				}
				position++
				if buffer[position] != rune('d') {
					goto l169
				}
				position++
				if buffer[position] != rune('s') {
					goto l169
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l169
				}
				if !_rules[ruleIdentifier]() {
					goto l169
				}
				{
					position171, tokenIndex171 := position, tokenIndex
					if !_rules[ruleConditionList]() {
						goto l171
					}
					goto l172
				l171:
					position, tokenIndex = position171, tokenIndex171
				}
			l172:
				add(ruleInheritanceComment, position170)
			}
			return true
		l169:
			position, tokenIndex = position169, tokenIndex169
			return false
		},
		/* 35 ErrorRecovery <- <(!('\r' / '\n') .)*> */
		nil,
		/* 36 UASTFieldName <- <Identifier> */
		func() bool {
			position174, tokenIndex174 := position, tokenIndex
			{
				position175 := position
				if !_rules[ruleIdentifier]() {
					goto l174
				}
				add(ruleUASTFieldName, position175)
			}
			return true
		l174:
			position, tokenIndex = position174, tokenIndex174
			return false
		},
	}
	p.rules = _rules
	return nil
}
