package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/dmytrogajewski/hercules/pkg/uast"
	"github.com/dmytrogajewski/hercules/pkg/uast/pkg/mapping"
)

func main() {
	var (
		output  = flag.String("o", "pkg/uast/embedded_mappings.gen.go", "output file for embedded mappings")
		quiet   = flag.Bool("q", false, "suppress output")
		verbose = flag.Bool("v", false, "verbose output")
	)
	flag.Parse()

	if err := runPrecompile(*output, *quiet, *verbose); err != nil {
		log.Fatal(err)
	}
}

func runPrecompile(outputFile string, quiet, verbose bool) error {
	uastmapsDir := "pkg/uast/uastmaps"
	if !quiet {
		fmt.Printf("Looking for .uastmap files in %s...\n", uastmapsDir)
	}

	entries, err := os.ReadDir(uastmapsDir)
	if err != nil {
		return fmt.Errorf("failed to read uastmaps directory: %w", err)
	}

	var uastmapFiles []string
	for _, entry := range entries {
		if !entry.IsDir() && strings.HasSuffix(entry.Name(), ".uastmap") {
			uastmapFiles = append(uastmapFiles, filepath.Join(uastmapsDir, entry.Name()))
		}
	}

	if len(uastmapFiles) == 0 {
		return fmt.Errorf("no .uastmap files found in %s/", uastmapsDir)
	}

	if !quiet {
		fmt.Printf("Found %d uastmap files to pre-compile\n", len(uastmapFiles))
	}

	var allMappings []uast.PrecompiledMapping
	successCount := 0

	for _, filePath := range uastmapFiles {
		if !quiet {
			fmt.Printf("Processing %s...\n", filepath.Base(filePath))
		}

		f, err := os.Open(filePath)
		if err != nil {
			if !quiet {
				fmt.Printf("Warning: Failed to open %s: %v\n", filepath.Base(filePath), err)
			}
			continue
		}
		defer f.Close()

		parser := &mapping.MappingParser{}
		rules, langInfo, err := parser.ParseMapping(f)
		if err != nil {
			if !quiet {
				fmt.Printf("Warning: Failed to pre-compile %s: %v\n", filepath.Base(filePath), err)
			}
			continue
		}

		languageName := filepath.Base(filePath)
		languageName = strings.TrimSuffix(languageName, ".uastmap")

		mapping := uast.PrecompiledMapping{
			Language:   languageName,
			Extensions: langInfo.Extensions,
			Rules:      rules,
		}

		allMappings = append(allMappings, mapping)
		successCount++
	}

	if !quiet {
		fmt.Printf("Successfully pre-compiled %d/%d uastmap files\n", successCount, len(uastmapFiles))
	}

	return runPrecompileGo(allMappings, outputFile, quiet)
}

func runPrecompileGo(mappings []uast.PrecompiledMapping, outputFile string, quiet bool) error {
	goCode := generateGoCode(mappings)

	if err := os.MkdirAll(filepath.Dir(outputFile), 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	if err := os.WriteFile(outputFile, []byte(goCode), 0644); err != nil {
		return fmt.Errorf("failed to write Go file: %w", err)
	}

	if !quiet {
		fmt.Printf("Go code with embedded mappings saved to: %s\n", outputFile)
	}

	return nil
}

func generateGoCode(mappings []uast.PrecompiledMapping) string {
	const goTemplate = `// Code generated by scripts/precompile.go. DO NOT EDIT.

package uast

import (
	"fmt"
	"strings"
	"github.com/dmytrogajewski/hercules/pkg/uast/pkg/mapping"
)

// embeddedMappingsData contains all pre-compiled UAST mappings
var embeddedMappingsData = []PrecompiledMapping{
{{range .}}
	{
		Language: "{{.Language}}",
		Extensions: []string{
{{range .Extensions}}
			"{{.}}",
{{end}}
		},
		Rules: []mapping.MappingRule{
{{range .Rules}}
			{
				Name: "{{.Name}}",
				Pattern: "{{.Pattern}}",
				{{if .Extends}}Extends: "{{.Extends}}",{{end}}
				UASTSpec: mapping.UASTSpec{
					{{if .UASTSpec.Type}}Type: "{{.UASTSpec.Type}}",{{end}}
					{{if .UASTSpec.Token}}Token: "{{.UASTSpec.Token}}",{{end}}
					{{if .UASTSpec.Roles}}Roles: []string{
{{range .UASTSpec.Roles}}
						"{{.}}",
{{end}}
					},{{end}}
					{{if .UASTSpec.Children}}Children: []string{
{{range .UASTSpec.Children}}
						"{{.}}",
{{end}}
					},{{end}}
					{{if .UASTSpec.Props}}Props: map[string]string{
{{range $key, $value := .UASTSpec.Props}}
						"{{$key}}": "{{$value}}",
{{end}}
					},{{end}}
				},
				{{if .Conditions}}Conditions: []mapping.Condition{
{{range .Conditions}}
					{
						Expr: "{{.Expr}}",
					},
{{end}}
				},{{end}}
			},
{{end}}
		},
	},
{{end}}
}

// embeddedMappingsAvailable checks if embedded mappings are available
func embeddedMappingsAvailable() bool {
	return len(embeddedMappingsData) > 0
}

// loadFromEmbeddedMappingsData loads from embedded mappings data
func (l *Loader) loadFromEmbeddedMappingsData() bool {
	// Convert pre-compiled mappings to parsers
	for _, precompiledMapping := range embeddedMappingsData {
		// Create a properly initialized DSLParser
		parser := &DSLParser{
			langInfo: &mapping.LanguageInfo{
				Name:       precompiledMapping.Language,
				Extensions: precompiledMapping.Extensions,
			},
			mappingRules: precompiledMapping.Rules,
		}

		// Initialize the language field
		if err := parser.initializeLanguage(); err != nil {
			fmt.Printf("Warning: Failed to initialize language for %s: %v\n", precompiledMapping.Language, err)
			continue
		}

		l.parsers[precompiledMapping.Language] = parser
		for _, ext := range precompiledMapping.Extensions {
			l.extensions[strings.ToLower(ext)] = parser
		}
	}

	return len(embeddedMappingsData) > 0
}

// OPTIMIZATION 1: Pre-compiled pattern matchers for O(1) lookup
{{range .}}
// {{.Language}}PatternMatcher provides pre-compiled pattern matching for {{.Language}}
type {{.Language}}PatternMatcher struct {
	patterns map[string]mapping.MappingRule
	ruleIndex map[string]int
	rules []mapping.MappingRule
}

func new{{.Language}}PatternMatcher() *{{.Language}}PatternMatcher {
	rules := []mapping.MappingRule{
{{range .Rules}}
		{
			Name: "{{.Name}}",
			Pattern: "{{.Pattern}}",
			{{if .Extends}}Extends: "{{.Extends}}",{{end}}
			UASTSpec: mapping.UASTSpec{
				{{if .UASTSpec.Type}}Type: "{{.UASTSpec.Type}}",{{end}}
				{{if .UASTSpec.Token}}Token: "{{.UASTSpec.Token}}",{{end}}
				{{if .UASTSpec.Roles}}Roles: []string{
{{range .UASTSpec.Roles}}
					"{{.}}",
{{end}}
				},{{end}}
				{{if .UASTSpec.Children}}Children: []string{
{{range .UASTSpec.Children}}
					"{{.}}",
{{end}}
				},{{end}}
				{{if .UASTSpec.Props}}Props: map[string]string{
{{range $key, $value := .UASTSpec.Props}}
					"{{$key}}": "{{$value}}",
{{end}}
				},{{end}}
			},
			{{if .Conditions}}Conditions: []mapping.Condition{
{{range .Conditions}}
				{
					Expr: "{{.Expr}}",
				},
{{end}}
			},{{end}}
		},
{{end}}
	}

	patterns := make(map[string]mapping.MappingRule)
	ruleIndex := make(map[string]int)
	
	for i, rule := range rules {
		patterns[rule.Name] = rule
		ruleIndex[rule.Name] = i
	}

	return &{{.Language}}PatternMatcher{
		patterns: patterns,
		ruleIndex: ruleIndex,
		rules: rules,
	}
}

func (m *{{.Language}}PatternMatcher) MatchPattern(patternName string) (mapping.MappingRule, bool) {
	rule, exists := m.patterns[patternName]
	return rule, exists
}

func (m *{{.Language}}PatternMatcher) GetRuleByIndex(index int) (mapping.MappingRule, bool) {
	if index < 0 || index >= len(m.rules) {
		return mapping.MappingRule{}, false
	}
	return m.rules[index], true
}

func (m *{{.Language}}PatternMatcher) GetRuleIndex(patternName string) (int, bool) {
	index, exists := m.ruleIndex[patternName]
	return index, exists
}

func (m *{{.Language}}PatternMatcher) GetAllPatterns() map[string]mapping.MappingRule {
	return m.patterns
}

func (m *{{.Language}}PatternMatcher) GetRulesCount() int {
	return len(m.rules)
}
{{end}}

// OPTIMIZATION 2: Fast pattern matcher registry
var patternMatchers = map[string]interface{}{
{{range .}}
	"{{.Language}}": new{{.Language}}PatternMatcher(),
{{end}}
}

// GetPatternMatcher returns a pre-compiled pattern matcher for the given language
func GetPatternMatcher(language string) interface{} {
	return patternMatchers[language]
}

// OPTIMIZATION 3: Compile-time validation functions
{{range .}}
func validate{{.Language}}Rules() error {
	matcher := new{{.Language}}PatternMatcher()
	
	// Validate rule inheritance
	for _, rule := range matcher.rules {
		if rule.Extends != "" {
			if _, exists := matcher.patterns[rule.Extends]; !exists {
				return fmt.Errorf("{{.Language}}: rule '%s' extends non-existent rule '%s'", rule.Name, rule.Extends)
			}
		}
		
		// Validate UAST spec
		if rule.UASTSpec.Type == "" {
			return fmt.Errorf("{{.Language}}: rule '%s' has empty UAST type", rule.Name)
		}
	}
	
	return nil
}
{{end}}

// OPTIMIZATION 4: Performance metrics
var patternMatchMetrics = struct {
	matches map[string]int64
	misses  map[string]int64
}{
	matches: make(map[string]int64),
	misses:  make(map[string]int64),
}

func RecordPatternMatch(language, pattern string, matched bool) {
	key := language + ":" + pattern
	if matched {
		patternMatchMetrics.matches[key]++
	} else {
		patternMatchMetrics.misses[key]++
	}
}

func GetPatternMatchStats() map[string]int64 {
	stats := make(map[string]int64)
	for k, v := range patternMatchMetrics.matches {
		stats[k+"_matches"] = v
	}
	for k, v := range patternMatchMetrics.misses {
		stats[k+"_misses"] = v
	}
	return stats
}
`

	tmpl, err := template.New("go").Parse(goTemplate)
	if err != nil {
		panic(fmt.Sprintf("failed to parse template: %v", err))
	}

	var buf strings.Builder
	if err := tmpl.Execute(&buf, mappings); err != nil {
		panic(fmt.Sprintf("failed to execute template: %v", err))
	}

	return buf.String()
}
